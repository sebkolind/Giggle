{"mappings":"AAAA,qBAA4B,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,CAAA;AAEnD,eAAsB;IACpB,QAAQ,CAAC,EAAE,OAAO,CAAA;CACnB,CAAA;AAOD,cAAqB;IACnB,GAAG,EAAE,MAAM,CAAA;IACX,EAAE,CAAC,EAAE,MAAM,CAAA;IACX,KAAK,CAAC,EAAE,MAAM,EAAE,CAAA;IAChB,QAAQ,CAAC,EAAE,MAAM,EAAE,CAAA;IACnB,UAAU,CAAC,EAAE,aAAa,CAAA;IAC1B,UAAU,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAA;IACnC,MAAM,CAAC,EAAE;QACP,GAAG,EAAE,MAAM,CAAA;QACX,GAAG,EAAE,MAAM,CAAA;QACX,GAAG,EAAE,MAAM,CAAA;QACX,IAAI,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,CAAA;KAChC,CAAA;CACF,CAAA;AAED,wBAA+B,CAAA,OAAO,GAAG;IACvC,CAAC,GAAG,EAAE,MAAM,GAAG,OAAO,CAAA;CACvB,KAAG,WAAW,GAAG;IAChB,CAAC,GAAG,EAAE,MAAM,GAAG,OAAO,CAAA;CACvB,CAAA,CAAA;AAOD,cAAqB,IAAI,CAAC,MAAM,EAAE,UAAU,CAAC,CAAA;ACnC7C,OAAO,MAAM,iBAAwB,MAAM,oCAAsB,QAAQ,gBAAgB,EAAE,CAY1F,CAAA","sources":["src/src/types.ts","src/src/index.ts","src/index.ts"],"sourcesContent":[null,null,"import { Giggle, Options, IndexableElement, Source, Context } from './types'\n\nexport const giggle = async (source: Giggle, options?: Options): Promise<IndexableElement[]> => {\n  if (source.elements == null) {\n    throw new Error('`elements` at the root is required.')\n  }\n\n  const elements = await Promise.all(source.elements.map(el => createElement(el.tag, el)))\n\n  if (options?.appendTo != null) {\n    elements.forEach(el => options.appendTo?.appendChild(el))\n  }\n\n  return elements\n}\n\nconst createElement = async (tag: string, source: Source): Promise<IndexableElement> => {\n  const el = document.createElement(tag) as IndexableElement\n  const context: Context = { el, source }\n\n  attachId(context)\n  attachClasses(context)\n  attachAttributes(context)\n  attachProperties(context)\n  await attachValues(context)\n\n  appendChildren(context)\n\n  return el\n}\n\nconst attachValues = async (context: Context): Promise<void> => {\n  if (context.source.values?.url == null || context.source.values.pool != null) {\n    return\n  }\n\n  const response = await fetch(context.source.values.url)\n\n  if (!response.ok) {\n    throw new Error(`Couldn't fetch ${context.source.values.url}`)\n  }\n\n  context.source.values.pool = await response.json()\n\n  const [key, value] = context.source.values.map.split(',')\n\n  switch (context.source.tag) {\n    case 'select':\n      context.source.elements = context.source.values.pool?.map(p => {\n        return {\n          tag: 'option',\n          attributes: { value: p[key.trim()] },\n          properties: { textContent: p[value.trim()] }\n        }\n      })\n      break\n\n    default:\n      console.error(`The tag \"${context.source.tag}\" is not supported for \"values\".`)\n      break\n  }\n}\n\nconst appendChildren = async (context: Context): Promise<void> => {\n  if (context.source.elements == null) {\n    return\n  }\n\n  const els = await giggle(context.source)\n\n  els.forEach(so => context.el.appendChild(so))\n}\n\nconst attachProperties = (context: Context): void => {\n  if (context.source.properties == null) {\n    return\n  }\n\n  Object.keys(context.source.properties).forEach(p => {\n    context.el[p] = context.source.properties?.[p]\n  })\n}\n\nconst attachAttributes = (context: Context): void => {\n  if (context.source.attributes == null) {\n    return\n  }\n\n  Object.keys(context.source.attributes).forEach(a => {\n    if (context.source.attributes?.[a] == null) {\n      return\n    }\n\n    context.el.setAttribute(a, context.source.attributes[a])\n  })\n}\n\nconst attachClasses = (context: Context): void => {\n  if (context.source.class == null) {\n    return\n  }\n\n  context.source.class.forEach(cl => context.el.classList.add(cl))\n}\n\nconst attachId = (context: Context): void => {\n  context.el.id = context.source.id || `${context.source.tag}-${Math.random().toString(16).substring(2, 8)}`\n}\n"],"names":[],"version":3,"file":"types.d.ts.map","sourceRoot":"../"}