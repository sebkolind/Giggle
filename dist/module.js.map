{"mappings":"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","sources":["src/index.ts"],"sourcesContent":["import { Giggle, Options, IndexableElement, Source, Context } from './types'\n\nexport const giggle = async (source: Giggle, options?: Options): Promise<IndexableElement[]> => {\n  if (source.elements == null) {\n    throw new Error('`elements` at the root is required.')\n  }\n\n  const elements = await Promise.all(source.elements.map(el => createElement(el.tag, el)))\n\n  if (options?.appendTo != null) {\n    elements.forEach(el => options.appendTo?.appendChild(el))\n  }\n\n  return elements\n}\n\nconst createElement = async (tag: string, source: Source): Promise<IndexableElement> => {\n  const el = document.createElement(tag) as IndexableElement\n  const context: Context = { el, source }\n\n  attachId(context)\n  attachClasses(context)\n  attachAttributes(context)\n  attachProperties(context)\n  await attachValues(context)\n\n  appendChildren(context)\n\n  return el\n}\n\nconst attachValues = async (context: Context): Promise<void> => {\n  if (context.source.values == null || context.source.values?.url == null || context.source.values.pool != null) {\n    return\n  }\n\n  const response = await fetch(context.source.values.url)\n\n  if (!response.ok) {\n    throw new Error(`Couldn't fetch ${context.source.values.url}`)\n  }\n\n  context.source.values.pool = await response.json()\n\n  const [key, value] = context.source.values.map.split(',').map(x => x.trim())\n\n  switch (context.source.values.tag) {\n    case 'option':\n      context.source.elements = context.source.values.pool?.map(p => {\n        return {\n          // FIXME: Tag is required, why does it complain?\n          tag: context.source.values!.tag,\n          attributes: { value: p[key] },\n          properties: { textContent: p[value] }\n        }\n      })\n      break\n\n    case 'radio':\n      context.source.elements = context.source.values.pool?.map(p => {\n        return {\n          tag: 'label',\n          elements: [\n            {\n              tag: 'span',\n              properties: { textContent: p[value] }\n            },\n            {\n              tag: 'input',\n              attributes: { value: p[key] },\n              properties: { type: 'radio' }\n            }\n          ]\n        }\n      })\n      break\n\n    default:\n      console.error(`The tag \"${context.source.values.tag}\" is not supported for \"values\".`)\n      break\n  }\n}\n\nconst appendChildren = async (context: Context): Promise<void> => {\n  if (context.source.elements == null) {\n    return\n  }\n\n  const els = await giggle(context.source)\n\n  els.forEach(so => context.el.appendChild(so))\n}\n\nconst attachProperties = (context: Context): void => {\n  if (context.source.properties == null) {\n    return\n  }\n\n  Object.keys(context.source.properties).forEach(p => {\n    context.el[p] = context.source.properties?.[p]\n  })\n}\n\nconst attachAttributes = (context: Context): void => {\n  if (context.source.attributes == null) {\n    return\n  }\n\n  Object.keys(context.source.attributes).forEach(a => {\n    if (context.source.attributes?.[a] == null) {\n      return\n    }\n\n    context.el.setAttribute(a, context.source.attributes[a])\n  })\n}\n\nconst attachClasses = (context: Context): void => {\n  if (context.source.class == null) {\n    return\n  }\n\n  context.source.class.forEach(cl => context.el.classList.add(cl))\n}\n\nconst attachId = (context: Context): void => {\n  context.el.id = context.source.id || `${context.source.tag}-${Math.random().toString(16).substring(2, 8)}`\n}\n"],"names":[],"version":3,"file":"module.js.map","sourceRoot":"../"}